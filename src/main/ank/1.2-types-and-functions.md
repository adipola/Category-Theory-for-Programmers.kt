```Haskell
x :: Integer
```
```kotlin
val x: BigInteger
```
................
```Haskell
f :: Bool -> Bool
```
```kotlin
val f: (Boolean) -> Boolean
```
................
```Haskell
f :: Bool -> Bool
f x = undefined
```
```kotlin:ank:silent
val f: (Boolean) -> Boolean = {
  x -> TODO()
}
```
................
```Haskell
f :: Bool -> Bool
f = undefined
```
```kotlin
val f: (Boolean) -> Boolean = TODO()
```
................
```Haskell
fact n = product [1..n]
```
```kotlin:ank:silent
fun fact(n: Int): Int =
  (1..n).reduce(Int::times)
```
................
```Haskell
absurd :: Void -> a
```
```kotlin
fun <A> absurd(): (Nothing) -> A
```
................
```Haskell
f44 :: () -> Integer
f44 () = 44
```
```kotlin:ank:silent
import java.math.BigInteger

val f44: () -> BigInteger = { 44.toBigInteger() }
```
................
```Haskell
fInt :: Integer -> ()
fInt x = ()
```
```kotlin:ank:silent
import java.math.BigInteger

val fInt: (BigInteger) -> Unit = { x -> Unit }
```
................
```Haskell
fInt :: Integer -> ()
fInt _ = ()
```
```kotlin:ank:silent
import java.math.BigInteger

val fInt: (BigInteger) -> Unit = { _ -> Unit }
```
................
```Haskell
unit :: a -> ()
unit _ = ()
```
```kotlin:ank:silent
val unit: () -> Unit = { }
```
................
```Haskell
data Bool = True | False
```
```kotlin:ank:silent
sealed class Boolean {
  object True : Boolean()
  object False : Boolean()
}
```
................
```kotlin:ank:playground
import arrow.syntax.function.memoize
//sampleStart
fun fak1(i:Int):Int =
    (if(i == 1) 1 else i * fak(i - 1))
        .also { println("computed for $i") }
        
val fakUnMemoized = {i:Int -> fak1(i)}.memoize()
/** 
* fak1 always recomputes subcomputations,
* because fakUnMemoized memoize soley over the initial input value.
* Whereas fakMemoized does not recompute memoized subcomputations.
*/
fun fak(i:Int):Int =
    (if(i == 1) 1 else i * fakMemoized(i - 1))
        .also { println("computed for $i") }

val fakMemoized = {i:Int -> fak(i)}.memoize()
//sampleEnd
fun main(){
    println(fakMemoized(8))
    println(fakMemoized(13))
}
```
................
```kotlin:ank:silent
import kotlin.random.Random
import arrow.syntax.function.memoize
val randomMemoized = 
    {until:Int -> Random.nextInt(until)}.memoize()
```
................
```kotlin:ank:silent
import kotlin.random.Random
import arrow.syntax.function.memoize
val randomSeedMemoized =
    {seed:Int -> Random(seed).nextInt()}.memoize()
```
................

